#pragma once

#include <string>
#include <compare>
#include <optional>
#include <stdexcept>

namespace zinc {

/**
 * FractionalIndex - Conflict-free ordering for list items.
 * 
 * Allows inserting items between any two existing items without
 * renumbering. Essential for CRDT-based collaborative reordering.
 * 
 * Implementation uses base-62 strings (0-9, A-Z, a-z) that can be
 * lexicographically compared. New indices are generated by finding
 * a string that sorts between two existing strings.
 * 
 * Based on the fractional indexing algorithm used by Figma and others.
 * 
 * Examples:
 *   between("a", "b") -> "aV" (or similar, sorts between a and b)
 *   between("", "a")  -> "V"  (start of list)
 *   between("z", "")  -> "z0V" (end of list)
 */
class FractionalIndex {
public:
    // Character set for encoding (base 62)
    static constexpr std::string_view DIGITS = 
        "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
    static constexpr size_t BASE = 62;
    static constexpr char SMALLEST = '0';
    static constexpr char LARGEST = 'z';
    static constexpr char MIDPOINT = 'V'; // Approximately middle of base-62
    
    /**
     * Create an empty (smallest possible) index.
     */
    FractionalIndex() = default;
    
    /**
     * Create an index from a string value.
     */
    explicit FractionalIndex(std::string value) : value_(std::move(value)) {
        validate();
    }
    
    /**
     * Generate the first index (for an empty list).
     */
    [[nodiscard]] static FractionalIndex first() {
        return FractionalIndex(std::string(1, MIDPOINT));
    }
    
    /**
     * Generate an index between two existing indices.
     * 
     * @param before The index that should come before the new one (empty = start)
     * @param after The index that should come after the new one (empty = end)
     * @return A new index that sorts between before and after
     */
    [[nodiscard]] static FractionalIndex between(
        const FractionalIndex& before, 
        const FractionalIndex& after
    ) {
        const auto& a = before.value_;
        const auto& b = after.value_;
        
        // Handle edge cases
        if (a.empty() && b.empty()) {
            return first();
        }
        
        if (a.empty()) {
            // Insert before b
            return generate_before(b);
        }
        
        if (b.empty()) {
            // Insert after a
            return generate_after(a);
        }
        
        // Both exist - find midpoint
        if (a >= b) {
            throw std::invalid_argument("FractionalIndex::between requires before < after");
        }
        
        return generate_between(a, b);
    }
    
    /**
     * Generate an index before this one.
     */
    [[nodiscard]] FractionalIndex before() const {
        return between(FractionalIndex{}, *this);
    }
    
    /**
     * Generate an index after this one.
     */
    [[nodiscard]] FractionalIndex after() const {
        return between(*this, FractionalIndex{});
    }
    
    /**
     * Get the string representation.
     */
    [[nodiscard]] const std::string& value() const noexcept {
        return value_;
    }
    
    /**
     * Check if this is an empty index.
     */
    [[nodiscard]] bool is_empty() const noexcept {
        return value_.empty();
    }
    
    // Comparison operators use lexicographic string comparison
    auto operator<=>(const FractionalIndex& other) const {
        return value_ <=> other.value_;
    }
    
    bool operator==(const FractionalIndex& other) const {
        return value_ == other.value_;
    }

private:
    std::string value_;
    
    void validate() const {
        for (char c : value_) {
            if (DIGITS.find(c) == std::string_view::npos) {
                throw std::invalid_argument(
                    "FractionalIndex contains invalid character: " + std::string(1, c));
            }
        }
    }
    
    [[nodiscard]] static size_t digit_value(char c) {
        auto pos = DIGITS.find(c);
        if (pos == std::string_view::npos) {
            throw std::invalid_argument("Invalid digit: " + std::string(1, c));
        }
        return pos;
    }
    
    [[nodiscard]] static char value_digit(size_t v) {
        if (v >= BASE) {
            throw std::out_of_range("Digit value out of range");
        }
        return DIGITS[v];
    }
    
    [[nodiscard]] static FractionalIndex generate_before(const std::string& b) {
        // Find the first position we can decrement
        std::string result;
        
        for (size_t i = 0; i < b.size(); ++i) {
            size_t bv = digit_value(b[i]);
            
            if (bv > 0) {
                // We can decrement here
                if (bv > 1) {
                    // Simple case: just use midpoint between 0 and b[i]
                    result += value_digit(bv / 2);
                    return FractionalIndex(result);
                } else {
                    // b[i] is '1', use '0' and continue with midpoint
                    result += SMALLEST;
                    result += MIDPOINT;
                    return FractionalIndex(result);
                }
            }
            
            result += SMALLEST;
        }
        
        // All zeros - append midpoint
        result += MIDPOINT;
        return FractionalIndex(result);
    }
    
    [[nodiscard]] static FractionalIndex generate_after(const std::string& a) {
        // Find the last position we can increment
        std::string result = a;
        
        for (size_t i = a.size(); i > 0; --i) {
            size_t av = digit_value(result[i - 1]);
            
            if (av < BASE - 1) {
                // We can increment here
                result[i - 1] = value_digit(av + (BASE - 1 - av) / 2 + 1);
                return FractionalIndex(result);
            }
        }
        
        // All at max - append midpoint
        result += MIDPOINT;
        return FractionalIndex(result);
    }
    
    [[nodiscard]] static FractionalIndex generate_between(
        const std::string& a, 
        const std::string& b
    ) {
        std::string result;
        size_t max_len = std::max(a.size(), b.size());
        
        for (size_t i = 0; i < max_len; ++i) {
            size_t av = (i < a.size()) ? digit_value(a[i]) : 0;
            size_t bv = (i < b.size()) ? digit_value(b[i]) : BASE;
            
            if (av == bv) {
                // Same digit, continue
                result += value_digit(av);
                continue;
            }
            
            if (bv - av > 1) {
                // Room to insert between these digits
                result += value_digit(av + (bv - av) / 2);
                return FractionalIndex(result);
            }
            
            // Difference is 1, need to go deeper
            result += value_digit(av);
            
            // Now we need to find something between a[i+1:] and ""
            // and before b (which is av+1 at this position)
            std::string a_suffix = (i + 1 < a.size()) ? a.substr(i + 1) : "";
            
            if (a_suffix.empty()) {
                result += MIDPOINT;
                return FractionalIndex(result);
            }
            
            // Generate between a_suffix and "end"
            auto suffix_result = generate_after(a_suffix);
            
            // But we need to make sure it's still less than b's suffix
            // Since b[i] is av+1 > av, anything we append will be < b
            result += suffix_result.value();
            return FractionalIndex(result);
        }
        
        // Should not reach here if a < b
        result += MIDPOINT;
        return FractionalIndex(result);
    }
};

} // namespace zinc

